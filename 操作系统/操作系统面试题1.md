## 操作系统面试题（一）

##### 1. 进程的有哪几种状态，状态转换图，以及各种状态之间的转换条件。

- 创建状态：进程正在被创建
- 就绪状态：当前进程已分配到除CPU意外的所有必要的资源，只要再获得CPU便可立即执行；进程被加入到就绪队列中等待CPU调度运行。
- 运行状态：当前进程已经获得处理机，程序正在执行。
- 阻塞状态：正在执行的进程，由于等待某个事件(如I/O请求、申请缓冲区失败、等待信号等)发生而无法执行时，便放弃处理机从而处于阻塞状态。
- 终止状态：进程运行完毕

![image-20200220232109159](https://eric-typora-img.oss-cn-beijing.aliyuncs.com/typora/20200220232112-432923.png)

<center>进程状态转换图</center>
 ##### 2. 进程与线程的联系和区别

进程：是具有一定独立功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源分配和调度的一个独立单位。

线程：是进程的一个实体，是CPU调度和分配的基本单位，它是比进程更小的能够独立运行的基本单位，是操作系统可识别的最小执行和调度单位。

**两者的联系：**

1. 一个线程只能属于一个进程，而一个进程可以有多个线程，且至少有一个线程。
2. 资源分配给进程，同一个进程的所有县城共享该进程的所有资源。同一进程中的多个线程共享代码段（代码和常量）、数据段（全局变量和静态变量）、扩展段（堆存储），但每一个进程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。
3. CPU分配给线程，即在CPU上运行的是线程。
4. 线程在执行过程中需要协作同步；不同进程的线程间要利用消息通信的方式实现同步。

**两者的区别：**

1. 进程有自己独立的地址空间，而线程没有。
2. 进程是资源分配的最小单位，线程是CPU调度的最小单位。
3. 进程和线程通信方式不同（线程之间的通信比较方便，同一进程下的线程共享数据，所以可以工作这些数据来进行线程间通信，但需要做好访问同步和互斥；进程之间的通信只能通过进程通信的方式进行）
4. 进程上下文切换开销大，线程开销小；
5. 进程的创建开销比线程的大（每启动一个进程，系统就会为它分配地址空间，建立数据表等）
6. 多进程程序更健壮。多线程程序只要一个线程死掉，会对其他线程造成影响，最终整个进程也死掉了；多进程程序一个进程死掉，不会对另一个进程造成影响，因为进程有自己独立的地址空间。

**为什么进程上下文切换进程比线程开销大？**

进程切换分两步：

1. 切换页目录以使用新的地址空间
2. 切换内核栈和硬件上下文

线程切换上下文只需要切换内核栈和硬件上下文。

上下文切换的性能消耗：

1. 线程上下文切换和进程上下文切换一个最主要的区别是线程的切换虚拟内存空间依然是相同的，但是进程切换时不同的，这两种上下文切换的处理都是通过操作系统内核来完成的。内核的这种切换过程伴随的最显著的性能消耗是将寄存器中的内容切换出去。
2. 进程的上下文切换另一个隐藏的损耗是上下文的切换会扰乱处理器的缓存机制。简单来说，一旦去切换上下文，处理器中所有缓存的内存地址一瞬间都作废了。还有一个显著的区别是当你改变虚拟内存空间的时候，处理的页表缓冲或者相当的东西没全部刷新，这将导致内存的访问在一段时间内相当的低效。但在线程的切换中，不会出现这个问题。

##### 3. 进程通信的几种方式

进程通信：是指进程之间的信息交换。PV操作是低级通信方式，高级通信方式是指以较高的效率传输大量数据的通信方式。

高级通信方式：

1. 共享内存：举例，word进程中ctrl-c 复制到剪切板，在excel进程中ctrl-v即完成了word和excel进程间的通信。
2. 消息传递
3. 管道通信

- 管道：是单向的、先进先出的、固定大小的字节流，它把一个进程的标准输入和另一个进程的标准输出连接在一起。管道分为匿名管道和命名管道，匿名管道只能实现本地机器上两个进程之间的通信，而不能实现跨网络的通信。命名管道不进可以在本机上实现两个进程间的通信还可以跨网络实现两个进程间的通信。
- 信号量：是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，放置某进程正在访问共享资源是，其他进程也访问该资源。因此，主要作为进程间以及统一进程内不同线程之间的同步手段。
- 消息队列：是一个在系统内核中用来保存消息的队列，它在系统内核中是以消息链表的形式出现的。消息队列跨服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。
- 共享内存：共享内存允许两个或多个进程访问同一个逻辑内存。这段内存可以被两个或多个进程映射到自身的地址空间中，一个进程写入共享内存的信息，可以被其他使用这个共享内存的进程，通过简单的内存读取读出，从而实现了进程间的通信。如果某个进程向共享内存写入数据，所做的改动将立即影响到可以访问同一段共享内存的任何其他进程。
- 套接字socket：套接字也是一种进程间的通信机制，与其他通信机制不同的是它可以用于不同机器间的通信。

##### 4. 线程同步几种方式。(一定要会写生产者、消费者问题，完全消化理解)

- 临界区：通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。
- 互斥量：为协调对一个共享资源的单独访问而设计，采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。互斥不仅能实现同一应用程序的公共资源安全共享 ，还能实现不同应用程序的公共资源安全共享。
- 信号量：主要作为进程之间及同一种进程的不同线程之间的同步和互斥手段。
- 事件（信号）：用来通知线程有些事件已发生，从而启动后继任务，保持多线程同步，也可以方便的实现多线程优先级的比较操作。



##### 5. 线程的实现方式. (也就是用户线程与内核线程的区别)

- 用户级线程：对于这类线程，有关线程管理的所有工作都有应用程序完成，内核意识不到线程的存在。在应用程序启动后，操作系统费赔给该程序一个进程号，以及其对应的内存空间等资源。应用程序通常现在一个线程中运行，该线程被称为主线程。在其运行的某个时刻，可以通过调用线程库中的函数创建一个在相同进程中运行的新线程。**用户级线程的好处是非常高效，不需要进入内核空间，但并发效率不高。**

- 内核级线程：对于这类线程，有关线程管理的工作→内核完成，应用程序没有进行线程管理的代码，只能调用内核线程的接口。内核维护线程及其内部的每个线程，调度也由内核基于线程架构完成。**内核级线程的好处是内核可以将不同线程很好地分配到不同的CPU以实现真正的并行计算**



##### 6. 用户态和核心态的区别

##### 8. 内存池、进程池、线程池。(c++程序员必须掌握)

#####  9. 死锁的概念，导致死锁的原因？如何处理死锁问题？

**概念：**如果一组进程中的每一个进程都在等待仅由该组进程中的其他进程才能引发的时间，那么改组进程就是死锁的。或者在两个或多个并发进程中，如果每个进程持有某种资源而又等待别的进程施法它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，成这组进程产生了死锁。通俗的将就是两个或多个进程被无限期的阻塞、相互等待的一种状态。

**死锁产生的原因：**

1. 竞争资源：请求同一有限资源的进程数多于可用资源数（资源不足，资源分配不当）
2. 进程推进顺序不当：进程执行中，请求和释放资源顺序不合理，如资源等待链。

**死锁产生的必要条件：**

1. 互斥条件：资源不能被共享，只能由一个进程使用。
2. 请求和保持条件：已经得到资源的进程可以再次申请新资源。
3. 非抢占条件：已经分配的资源不能从相应的进程中被强制地剥夺。
4. 循环等待条件：系统中若干进程组成环路，该环路中每个进程都在等待相邻进程占用的资源。

**处理死锁的四个方式：**

1. 预防死锁：破坏产生死锁的四个必要条件中的一个或者多个(互斥条件无法破坏)；实现起来比较简单，但若果限制过于严格会降低系统资源利用率和吞吐量。

   具体方法： 

   - 打破请求与保持条件：可以实行<font color = red> 资源预先分配</font>策略（进程在运行前一次性向系统申请它所需要的全部资源，若所需全部资源得不到满足，则不分配任何资源，此进程暂时不运行；只有当系统能满足当前进程所需的全部资源时，才一次性将所申请资源全部分配给该进程）或者只允许进程在没有占用资源时才可以申请资源（一个进程可申请一些资源并使用他们，但是在当前进程申请更多资源之前，必须全部释放当前所占有的资源）。但这种策略存在一些缺点：在很多情况下无法预知一个进程执行前所需的全部资源，因为进程是动态执行的，不可预知的；同时，会降低资源利用率，导致降低了进程的并发性。
   - 打破不可剥夺条件：允许进程强制剥夺使用其他进程占有的资源，从而破坏不可剥夺条件。
   - 打破循环等待条件：实行<font color = red> 资源有序分配</font>，破坏环路条件。对所有资源排序编号，所有进程资源的请求必须严格按照资源序号递增的顺序提出，即只有占用了消耗资源才能申请大号资源，这样就不会产生回路，预防死锁的发生。

2. 避免死锁：在资源的动态分配中，防止系统进入不安全状态（可能产生死锁的状态），比如，银行家算法

   具体方法：

   避免死锁的基本四星是动态监测资源分配状态，以确保循环等待条件不成立，从而确保处于安全状态。所谓安全状态是指：如果系统能按某个顺序为每个进程分配资源（不超过其最大值），那么系统状态是安全的的，换句话说就是，如果存在一个安全序列，那么系统处于安全状态。资源分配图算法和银行家算法是两种经典的死锁避免的算法，其可以确保系统始终处于安全状态。其中，资源分配图算法应用场景为每种资源类型只有一个实例（申请边，分配边，需求边，不形成环才允许分配），而银行家算法应用于每种资源可以有多个实例的场景。

   **银行家算法：**

   **资源分配图算法：**

3. 检测死锁：允许系统运行过程中产生死锁，在死锁发生之后，采用一定的算法进行检测，并确定与死锁相关的额资源和进程，采取相关方法清除检测到的死锁。实现难度大。
4. 解除死锁：与死锁检测配合，将系统从死锁中解脱出来（撤销进程或者剥夺资源）。对检测到的和死锁相关的进程和资源，通过撤销或者挂起的方式，释放一些资源并将其分配各处于阻塞状态的进程，使其转变为就绪。实现难度大


**处理死锁的策略：**

1. 忽略该问题

2. 检测死锁并修复

3. 仔细地对资源进行动态分配，避免死锁

4. 通过破除死锁四个必要条件之一来方式死锁产生

   

##### 10. 操作系统的四个特性

- 并发：同一段时间内多个程序执行
- 共享：系统中的资源可以被内存中多个并发执行的进程或者线程共同使用
- 虚拟：通过时分复用（如多道程序技术，分时系统）以及空分复用（如虚拟内存）技术，实现把一个物理试题虚拟为多个
- 异步：系统中的进程是以走走停停的方式执行的，且以一种不可预知的速度推进。

##### 11.操作系统的主要功能

- 处理机管理：处理机分配都是以进程为单位，所以处理机管理也被看做是进程管理。包括进程控制，进程同步，进程通信和调度（作业调度和进程调度）
- 存储器管理（或内存管理）：内存分配、内存保护、地址映射、内存扩充
- 设备管理：管理所有外围设备，包括完成用户IO请求；为用户进程分配IO设备；提高IO设备利用率；提高IO速度；方便IO的使用
- 文件管理：管理用户文件和系统文件，方便使用同时保证安全性。包括：文件存储空间管理，目录管理，文件读写管理以及文件共享和保护提供用户接口：程序接口（如API）和用户接口（如GUI）

##### 13. 进程调度算法。(周转时间 = 程序结束时间 -- 开始服务时间、带权周转时间= 周转时间 / 要求服务时间)

**先来先服务调度算法FCFS(First Come,First Served):**

- 既可以作为作业调度算法也可以作为进程调度算法；
- 按作业或者进程到达的先后顺序依次调度；
- 公平、简单、非抢占、不适合交互式；
- 未考虑任务特性，平均等待时间可以缩短；
- 对长作业比较有利。

**短作业优先调度算法SJF(Shortest Job First):** 

- 算法从就绪队列中选择估计时间最短的作业进行处理，直到得出结果或者无法继续执行；
- 缺点：不利于长作业；未考虑作业的重要性；运行时间是预估的，并不靠谱
- SJF可以保证最小的平均等待时间

**SRJF（Shortest Remaining Job First）**

- SJF的可抢占版本，比SJF更有优势
- SJF和SRJF是如何知道CPU区间大小的？根据历史进行预测：指数平均法

**优先级调度:**

- 可以是可抢占的，也可以是非抢占的
- 每个任务关联一个优先级，优先级越高越先分配到CPU，相同优先级的先到先服务；
- 问题：优先权太低的任务一直就绪，但却无法得到运行，会出现“饥饿”现象

**Round-Robin(RR)轮转调度算法：**

- 可抢占的；
- 设置一个时间片，按时间片来轮转调度（“轮叫”算法），时间片用完后中断，暂停当前进程并将其放入队列尾部，循环。
- 优点：定时有响应，等待时间较短
- 缺点：上下文切换次数较多；
- 时间片太大，响应时间太长；吞吐量变小，周转时间变长；当时间片过长是，退化为FCFS

**多级队列调度：**

- 按照一定的规则建立多个进程队列
- 不同的队列有固定的优先级（高优先级有抢占权）
- 不同的队列可以给不同的时间片和采用不同的调度方法；
- 存在的问题1：没有区分I/O bound 和 CPU bound
- 存在的问题2：也存在一定程度的“饥饿”现象。

**多级反馈队列：**

- 设置多个就绪队列并未每个队列设置不同的优先级，第一个队列优先级最高，其余依次递减。优先级越高的队列分配的时间片越短。
- 任务可以在队列之间移动（进程到达后按FCFS放入第一队列，如果调度执行后没有完成，则放到第二队列尾部等待调度，如果第二次调度仍然没有完成，则放入第三队列尾部 ......）
- 可以根据“享用”CPU时间多少来移动队列，阻止“饥饿”，如果进程使用过多的CPU时间，则会被转移至优先级更低的队列。
- 最通用的调度算法，多数OS都是使用该方法或其变形。

**高相应比算法：** 响应比 = (等待时间 + 要求服务时间)/要求服务时间;

##### 14. Windows内存管理的方式(块式、页式、段式、段页式)

##### 15. 内存连续分配方式采用的几种算法及各自优劣

##### 16. 动态链接及静态链接

静态链接库： 是把(lib)文件中用到的函数代码直接链接进目标程序，程序在运行时不再需要其他的库文件；主要包含一堆程序员自定的变量和函数。

动态链接库：是把调用的函数所在的文件模板(dll)和调用函数在文件中的位置等信息链接进目标程序，程序运行的时候再从DLL中寻找相应函数代码，因此需要相应DLL文件的支持。

静态链接库的优点：

1. 代码装载速度快，执行速度略比动态链接库快。
2. 只需要保证在开发者的计算机中有正确的*.lib*文件，在以二进制形式发布程序时不需要考虑在用户的计算机上*.lib*文件是否存在及版本问题。

静态链接库的不足：

1. 生成的可执行文件体积较大，包含相同的公共代码，造成浪费；

动态链接库的优点：

1. 更加节省内存并减少页面交换；
2. dll文件与exe文件，相互独立，只要输出接口不变（即名称、参数、返回值类型及调用约定不变），更换dll文件不会对exe文件造成任何影响，因而极大地提高了可维护性和可扩展性；
3. 不同编程语言编写的程序只要按照函数调用约定就可以调用同一个dll函数；
4. 适用于大规模的软件开发，是开发过程独立、耦合度低，便于不同开发者和开发组织之间进行开发和测试。

动态链接库的不足：

​	使用动态链接库的应用程序不是自完备的，它依赖的dll模板也要存在，如果使用在入市动态链接，程序启动时发现dll不存在，系统将终止程序并给出错误信息。而使用运行时动态链接，系统不会终止，但由于dll中的导出函数不可用，程序会加载失败；速度比静态链接慢。当某个模块更新后，如果新模块与旧的模块不兼容，那么那些需要该模块才能运行的软件就会统统死掉。

动态链接与静态链接的区别：

1. 使用静态库的时候，静态链接库要参与编译，在生成文件之前的链接过程中，要将静态链接库的全部指令直接链接如可执行文件中。动态链接库提供了一个方法，使进程可以调用不属于其可执行代码的函数。函数的可执行代码位于*.dll* 文件中，该dll包含一个或多个已被编译、链接并与使用他们的进程分开存储的函数。
2. 静态链接库不能在包含其他静态库或者动态库，而在动态链接库中可以在包含其他动态或者静态库。
3. 静态库在编译的时候，就将库函数装载到程序中去了，而动态库函数必须在运行的时候才被装载，所以使用静态库速度快一些。
4. 如果再当前工程中有多处对动态库（dll）文件中同一个函数的调用，那么执行时，这个函数只会留下一份拷贝。但是如果有多处对静态库（lib）文件中同一个函数的调用，则在执行时，该函数将在当前程序的执行空间中留下多份拷贝，且是又一处调用就会又一次拷贝。所以动态连声称的可执行文件体积较大。

详细过程参见[<font color = red>这里</font>](https://www.cnblogs.com/gaoyihan/p/4723332.html)

##### 17. 基本分页、请求分页储存管理方式

##### 19. 分段分页方式的比较各自优缺点

##### 20. 几种页面置换算法，会算所需换页数。(LRU用程序如何实现？)

##### 21. 虚拟内存的定义及实现方式

##### 23. DMA

##### 24. Spooling

##### 25. 外存分配的几种方式，及各种优劣



[参考1](https://www.cnblogs.com/inception6-lxc/p/9073983.html)

[参考2](https://my.oschina.net/u/1186503/blog/1632610)

[参考3](https://blog.csdn.net/Yasin0/article/details/81879569)

[参考4](https://www.cnblogs.com/zhangfuxiao/p/11624261.html)

[5](https://www.jianshu.com/p/98997fd3f52a)

[6](https://segmentfault.com/a/1190000011028633)

[7](https://www.cnblogs.com/midiyu/p/8065676.html)

[8](https://blog.csdn.net/cdlwhm1217096231/article/details/90814210)

[操作系统内存管理知识点](https://blog.csdn.net/qq_29677867/article/details/91038642)

