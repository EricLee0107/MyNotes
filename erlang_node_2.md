#Erlang/OTP杂记２

## 性能优化
1. cprof
2. fprof

## 细节

### 标准数据类型占用大小

### 常用操作细节

1. 原子不会被垃圾回收，只有重启节点才可以删除。
2. 原子表上限一百多万项，超出会导致内存溢出，所以尽量避免动态创建原子
3. 浮点数、大数、堆型二进制串保存在进程堆中，进程间传递会被复制。
4. 引用技术型二进制串保存在所有进程共享的全局内存区域，进程间传递只需要传递一个指针。
5. 判断二进制串处理效率可以设置ERL_COMPILER_OPTIONS设置为bin_opt_info 可以输出一些对于判断二进制串处理相关的一些有用的警告和信息。
6. 元组的更新本质是复制，所以读取速度快，但写入速度慢。
7. ++ 与　lists:append是一样的，--与lists:subtract是一样的，这两个操作都是平方时间复杂度。对于顺序不重要的列表，先排序再调用ordsets:subtract/2会更快。
8. list_to_atom应该慎用（原子不会回收，可能导致内存溢出），可以尝试list_to_existing_atom来生成原子。
9. size适用于元组和二进制串，但不适用于列表;length仅适用于列表。
10. size用于元组时返回的是元素个数；用于二进制串返回的是字节数，对于二进制串最好使用`byte_size`或者`bit_size`来代替`size`，用于数组最好使用`tuple_size`；`byte_size`是向上取整的（整字节）

### 函数调用速度

|函数调用类型|耗时|
|:--|:--|
|本地函数|非常快|
|已知的远程函数|几乎和本地函数模块一样快|
|未知的远程函数|大约比本地调用慢3倍|
|Fun函数调用|比本地调动慢2~3倍|
|元调用:apply/3|比本地调用慢6~10倍|

