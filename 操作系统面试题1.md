## 操作系统面试题（一）

##### 1. 进程的有哪几种状态，状态转换图，以及各种状态之间的转换条件。

- 创建状态：进程正在被创建
- 就绪状态：当前进程已分配到除CPU意外的所有必要的资源，只要再获得CPU便可立即执行；进程被加入到就绪队列中等待CPU调度运行。
- 运行状态：当前进程已经获得处理机，程序正在执行。
- 阻塞状态：正在执行的进程，由于等待某个事件(如I/O请求、申请缓冲区失败、等待信号等)发生而无法执行时，便放弃处理机从而处于阻塞状态。
- 终止状态：进程运行完毕

![image-20200220232109159](https://eric-typora-img.oss-cn-beijing.aliyuncs.com/typora/20200220232112-432923.png)

<center>进程状态转换图</center>
 ##### 2. 进程与线程的联系和区别

进程：是具有一定独立功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源分配和调度的一个独立单位。

线程：是进程的一个实体，是CPU调度和分配的基本单位，它是比进程更小的能够独立运行的基本单位，是操作系统可识别的最小执行和调度单位。

**两者的联系：**

1. 一个线程只能属于一个进程，而一个进程可以有多个线程，且至少有一个线程。
2. 资源分配给进程，同一个进程的所有县城共享该进程的所有资源。同一进程中的多个线程共享代码段（代码和常量）、数据段（全局变量和静态变量）、扩展段（堆存储），但每一个进程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。
3. CPU分配给线程，即在CPU上运行的是线程。
4. 线程在执行过程中需要协作同步；不同进程的线程间要利用消息通信的方式实现同步。

**两者的区别：**

1. 进程有自己独立的地址空间，而线程没有。
2. 进程是资源分配的最小单位，线程是CPU调度的最小单位。
3. 进程和线程通信方式不同（线程之间的通信比较方便，同一进程下的线程共享数据，所以可以工作这些数据来进行线程间通信，但需要做好访问同步和互斥；进程之间的通信只能通过进程通信的方式进行）
4. 进程上下文切换开销大，线程开销小；
5. 进程的创建开销比线程的大（每启动一个进程，系统就会为它分配地址空间，建立数据表等）
6. 多进程程序更健壮。多线程程序只要一个线程死掉，会对其他线程造成影响，最终整个进程也死掉了；多进程程序一个进程死掉，不会对另一个进程造成影响，因为进程有自己独立的地址空间。

**为什么进程上下文切换比线程开销大？**

进程切换分两步：

1. 切换页目录以使用新的地址空间
2. 切换内核栈和硬件上下文

线程切换上下文只需要切换内核栈和硬件上下文。

上下文切换的性能消耗：

1. 线程上下文切换和进程上下文切换一个最主要的区别是线程的切换虚拟内存空间依然是相同的，但是进程切换时不同的，这两种上下文切换的处理都是通过操作系统内核来完成的。内核的这种切换过程伴随的最显著的性能消耗是将寄存器中的内容切换出去。
2. 进程的上下文切换另一个隐藏的损耗是上下文的切换会扰乱处理器的缓存机制。简单来说，一旦去切换上下文，处理器中所有缓存的内存地址一瞬间都作废了。还有一个显著的区别是当你改变虚拟内存空间的时候，处理的页表缓冲或者相当的东西没全部刷新，这将导致内存的访问在一段时间内相当的低效。但在线程的切换中，不会出现这个问题。

##### 3. 进程通信的几种方式

进程通信：是指进程之间的信息交换。PV操作是低级通信方式，高级通信方式是指以较高的效率传输大量数据的通信方式。

高级通信方式：

1. 共享内存：举例，word进程中ctrl-c 复制到剪切板，在excel进程中ctrl-v即完成了word和excel进程间的通信。
2. 消息传递
3. 管道通信

- 管道：是单向的、先进先出的、固定大小的字节流，它把一个进程的标准输入和另一个进程的标准输出连接在一起。管道分为匿名管道和命名管道，匿名管道只能实现本地机器上两个进程之间的通信，而不能实现跨网络的通信。命名管道不进可以在本机上实现两个进程间的通信还可以跨网络实现两个进程间的通信。
- 信号量：是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，放置某进程正在访问共享资源是，其他进程也访问该资源。因此，主要作为进程间以及统一进程内不同线程之间的同步手段。
- 消息队列：是一个在系统内核中用来保存消息的队列，它在系统内核中是以消息链表的形式出现的。消息队列跨服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。
- 共享内存：共享内存允许两个或多个进程访问同一个逻辑内存。这段内存可以被两个或多个进程映射到自身的地址空间中，一个进程写入共享内存的信息，可以被其他使用这个共享内存的进程，通过简单的内存读取读出，从而实现了进程间的通信。如果某个进程向共享内存写入数据，所做的改动将立即影响到可以访问同一段共享内存的任何其他进程。
- 套接字socket：套接字也是一种进程间的通信机制，与其他通信机制不同的是它可以用于不同机器间的通信。

##### 4. 线程同步几种方式。(一定要会写生产者、消费者问题，完全消化理解)

##### 5. 线程的实现方式. (也就是用户线程与内核线程的区别)

- 用户级线程：对于这类线程，有关线程管理的所有工作都有应用程序完成，内核意识不到线程的存在。在应用程序启动后，操作系统费赔给该程序一个进程号，以及其对应的内存空间等资源。应用程序通常现在一个线程中运行，该线程被称为主线程。在其运行的某个时刻，可以通过调用线程库中的函数创建一个在相同进程中运行的新线程。**用户级线程的好处是非常高效，不需要进入内核空间，但并发效率不高。**

- 内核级线程：对于这类线程，有关线程管理的工作→内核完成，应用程序没有进行线程管理的代码，只能调用内核线程的接口。内核维护线程及其内部的每个线程，调度也由内核基于线程架构完成。**内核级线程的好处是内核可以将不同线程很好地分配到不同的CPU以实现真正的并行计算**



##### 6. 用户态和核心态的区别

##### 7. 用户栈和内核栈的区别

##### 8. 内存池、进程池、线程池。(c++程序员必须掌握)

#####  9. 死锁的概念，导致死锁的原因？如何处理死锁问题？

**概念：**如果一组进程中的每一个进程都在等待仅由该组进程中的其他进程才能引发的时间，那么改组进程就是死锁的。或者在两个或多个并发进程中，如果每个进程持有某种资源而又等待别的进程施法它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，成这组进程产生了死锁。通俗的将就是两个或多个进程被无限期的阻塞、相互等待的一种状态。

**死锁产生的原因：**

1. 竞争资源：请求同一有限资源的进程数多于可用资源数（资源不足，资源分配不当）
2. 进程推进顺序不当：进程执行中，请求和释放资源顺序不合理，如资源等待链。

**死锁产生的必要条件：**

1. 互斥条件：资源不能被共享，只能由一个进程使用。
2. 请求和保持条件：已经得到资源的进程可以再次申请新资源。
3. 非抢占条件：已经分配的资源不能从相应的进程中被强制地剥夺。
4. 循环等待条件：系统中若干进程组成环路，该环路中每个进程都在等待相邻进程占用的资源。

**处理死锁的四个方式：**

1. 预防死锁：破坏产生死锁的四个必要条件中的一个或者多个；实现起来比较简单，但若果限制过于严格会降低系统资源利用率和吞吐量。
2. 避免死锁：
3. 检测死锁：
4. 解除死锁：

**处理死锁的策略：**

1. 忽略该问题
2. 检测死锁并修复
3. 仔细地对资源进行动态分配，避免死锁
4. 通过破除死锁四个必要条件之一来方式死锁产生





##### 11. 处理死锁的四个方式

#####  12. 预防死锁的方法、避免死锁的方法

##### 13. 进程调度算法。(周转时间 = 程序结束时间 -- 开始服务时间、带权周转时间= 周转时间 / 要求服务时间)

##### 14. Windows内存管理的方式(块式、页式、段式、段页式)

##### 15. 内存连续分配方式采用的几种算法及各自优劣

##### 16. 动态链接及静态链接

##### 17. 基本分页、请求分页储存管理方式

##### 18. 基本分段、请求分段储存管理方式

##### 19. 分段分页方式的比较各自优缺点

##### 20. 几种页面置换算法，会算所需换页数。(LRU用程序如何实现？)

##### 21. 虚拟内存的定义及实现方式

##### 22. 操作系统的四个特性

##### 23. DMA

##### 24. Spooling

##### 25. 外存分配的几种方式，及各种优劣



[参考1](https://www.cnblogs.com/inception6-lxc/p/9073983.html)