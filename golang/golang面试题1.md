## golang总结

##### 简述Go中`main()`函数和`init()`函数的区别

相同：

1. 都是go特定保留的函数名
2. 都不能有任何的参数和返回值
3. init和main是自动执行的，我们不应该显示调用它们。

不同：

1. init函数可以出现在任何包里（也可以不出现），但main函数只能出现在main包中且必须有。

2. main包最多有一个main函数，但可以有多个init函数（但是不推荐一个包中有多个init函数）

   相关知识点：

   main和init的执行过程：

   ![image-20200303222229305](https://eric-typora-img.oss-cn-beijing.aliyuncs.com/typora/20200303222230-15541.png)

   <center>图片来源于Go语言程序设计</center>


##### 数组和切片的区别

1. 数组是值传递，切片是引用传递
2. 数组是定长的，切片可调整长度
3. 数组的容量总是等于长度，切片的容量和长度可以不相等
4. 切片可以通过数组来创建

相关知识点：

切片的底层其实是一个隐藏数组，该隐藏的数组与Go语言中所有数组一样都是固定长度的。切片相当于对于隐藏数组的一个窗口，可以看到部分隐藏数组的内容（窗口的大小相当于切片长度，而整个隐藏数组的长度则为切片的容量）

那为什么切片可以扩容呢？

 原因是当一个切片无法容纳更多元素，Go语言会生成一个容量更大的切片，然后将原有的元素和新元素一起拷贝到新切片中。

切片的扩容规则：

一般情况下新容量会是原容量的两倍，但是当原切片长度大于等于1024时，go将会以原容量1.25倍作为新的基准，不断扩容，直到结果不小于原长度与追加的元素之和。

##### new和make的区别

内建函数new用来分配内存，第一个参数是一个类型而不是一个值，返回值是一个指向新分配类型零值的<font color = red>指针</font>,new并没有初始化内存，其指针指向的内容的值为零值。

内建函数make用来为`slice`、`map`、`chan`类型分配和初始化一个对象（make只能用在这三种类型上），与new类似，第一个参数也是一个类型而不是一个值，跟new不同的是，make返回类型的值，而不是指针，且返回值依赖于具体传入的类型。

相关问题：

为什么slice、map、chan需要通过make来初始化？

slice：当make用于创建一个切片是，它会创建一个隐藏的初始化为零值的数组，然后返回一个引用该隐藏数组的切片。该隐藏的数组与Go语言中所有数组一样都是固定长度的。通过make有两张语法创建切片，第一种，`make([]Type, length,capacity)`，比如`make([]int,0,10)`分配一个长度为0且容量为10的切片（**注意：切片的容量必须大于切片的长度**）。第二种`make([]Type,length)`比如`make([]int,10)`分配一个长度为10 容量为10的切片。

map:需要为空的映射分配足够的空间以容纳指定数量的元素。如果参数省略则会分配一个起始大小较小的空间。

通道：通道需要指定缓冲区容量来初始化通道的缓冲区，如果为0或者忽略大小，则通道不缓冲。

##### Go常用命令

| 命令        | 作用                          |
| ----------- | ----------------------------- |
| go vet      | 运行go tool vet               |
| go env      | 查看go的环境变量              |
| go build    | 编译包和依赖文件              |
| go run      | 编译并运行go程序              |
| go test     | 运行测试                      |
| go get      | 下载并安装包和依赖            |
| go install  | 编译并安装包和依赖            |
| go list     | 列出包                        |
| go clean    | 移出go build产生的对象文件    |
| go tool     | 运行go提供的工具              |
| go fmt      | 代码格式化                    |
| go version  | 显示go的版本                  |
| go bug      | 启动错误报告                  |
| go doc      | 生成文档                      |
| go fix      | 运行go tool fix               |
| go generate | 从processing source生成go文件 |

##### Printf()、Sprintf()、Fprintf()函数的区别用法是什么？

首先三个函数都是将格式化好的字符串输出，只是输出的目标不一样：

- `Printf()`是把格式字符串输出到标准输出（一般是屏幕，但也可以重定向）。`Printf()`是和标准输出文件（stdout）相关联的，`FPrintf()`则没有这个限制。

- `Sprintf()`是把格式字符串输出到指定字符串中，所以参数比`Printf()`多一个`char*`（目标字符串地址）。

- `FPrintf()`是把格式字符串输出到指定文件设备中，所以参数比`Printf()`多一个文件指针`FILE*`。主要用于文件操作。`FPrintf()`是格式化输出到一个stream,通常是到文件。

相关知识点：
字符串格式化常用动词及功能

| 动词 | 功能                                     |
| ---- | ---------------------------------------- |
| %p   | 指针，十六进制方式显示                   |
| %v   | 按值的本来值输出                         |
| %+v  | 在 %v 基础上，对结构体字段名和值进行展开 |
| %#v  | 输出 Go 语言语法格式的值                 |
| %T   | 输出 Go 语言语法格式的类型和值           |
| %%   | 输出 % 本体                              |
| %b   | 整型以二进制方式显示                     |
| %o   | 整型以八进制方式显示                     |
| %d   | 整型以十进制方式显示                     |
| %x   | 整型以十六进制方式显示                   |
| %X   | 整型以十六进制、字母大写方式显示         |
| %U   | Unicode 字符                             |
| %f   | 浮点数                                   |

  ##### sync.WaitGroup的使用场景

当程序需要并发，需要创建多个goroutine，并且一定要等这些并发全部完成后才能继续接下来的程序执行，此时需要用到sysc.WaitGroup。

WaitGroup的特点是Wait()可以用来阻塞直到队列中的所有任务都完成时(WatiGroup计数为0)才解除阻塞，而不需要sleep一个固定的时间来等待，但是其缺点是无法指定固定的goroutine数目。

##### 说说go语言的同步锁

- Mutex互斥锁，当一个goroutine获得了Mutex之后，其他goroutine只能等待Mutex的持有者释放这个锁之后才可以得到这个锁。
- RWmutex在读锁占用的情况下会阻止写，但不会阻止读；在写锁占用情况下，会阻止任何其他goroutine(读或者写)，整个锁相当于该goroutine独占。主要适用一些大多数情况下是读取变量的状态，所以多个桉树可以安全的并发执行读操作。

#### Go基础

##### for语句

for循环支持continue和break来控制循环，而且可以通过声明标签然后通过break跳转到最外层循环。

for循环中的大括号是必须的，但分好只在可选的前置后者后置声明语句都存在的时候才需要。

for循环不支持以逗号为分隔的多个赋值语句，多变量初始化可以通过平行赋值（a,b = x,y）的方式。

for循环实现有序映射的迭代：

方案1：创建一个有键组成的切片，然后对切片排序，然后有序获取每个键的值。

方案2：优先使用一个有序数据结构，如：有序映射。

##### switch语句

单个case中可以出现多个结果选项，多个选项之间以逗号分隔。

```go
switch x.(Type){
    case int,int8,int16:
    	fmt.Printf("X is int")
    default：
    	fmt.Printf("x is other type")
}
```

只有在case中明确添加fallthrough关键字，才会继续执行紧跟的下一个case;

`x.(type)`获取变量x的类型，可以用于switch语句的条件开关。

**select关键字用法**
	一个select语句用来选择哪个case中的发送或者接收操作可以被立即执行。类似于switch语句，但是他的case涉及到channel有关的I/O操作。换一种说法就是，select是用来监听和channel有关的IO操作，当IO操作发生时，出发相应的动作。

执行步骤：

1. 所有的channel表达式都会被求值，所有被发送的表达式都会被求值。求值顺序：自上而下，从左到右。如果是选择一个发送或者接受的channel，无论哪个case进行操作，所有表达式都会被执行。RecvStmt左侧短变量成名或赋值为被评估。
2. 如果有一个或多个IO操作可以完成，则Go运行时系统会随机的选择一个执行，否则的话，如果有default分支，则执行default分支语句，如果连default都没有，则select语句会一直阻塞，直到至少有一个IO操作可以进行

  go语言中的引用类型包含哪些？
​	数组切片、字典(map)、通道（channel）、接口（interface）
go语言中指针运算有哪些？
​	可以通过“&”取指针的地址
可以通过“*”取指针指向的数据

##### 说说go语言的channel特性？

1. 给一个 nil channel 发送数据，造成永远阻塞
2.  从一个 nil channel 接收数据，造成永远阻塞
3.  给一个已经关闭的 channel 发送数据，引起 panic
4.  从一个已经关闭的 channel 接收数据，如果缓冲区中为空，则返回一个零值
5.  无缓冲的channel是同步的，而有缓冲的channel是非同步的

相关知识点：

**channel的初始化**

无缓冲：`c := make(chan int)`

有缓冲：`c := make(chan string ,10)`

**特性**

- channel分为有缓冲和无缓冲

- channel可以划分方向，可以只能写或者只能读

- 发送操作和接收操作在什么时候会被阻塞

- 对于有缓冲的通道，如果通道已满，则所有的发送操作就会阻塞，直到通道中有元素被取走；如果通道已空，则所有的接收操作就会阻塞，直到通道中有新的元素。

- 对于无缓冲通道，无论发送操作还是接收操作一开始就是阻塞的，只有配对的操作出现才开始执行。

- channel可以关闭，关闭后的channel不可以继续使用



**收发操作何时会引起panic**

1. 通道关闭，在进行发送操作时会引发panic

2. 关闭一个已经关闭的通道会引发panic

**如何判断一个channel是否关闭？**

如果我们对一个已经关闭了的channel，继续读的话，即使它已经空了，仍然会返回一个空值。所以判 断一个channel是否是一个关闭状态是十分有必要的。可以在接收返回值的时候多加一个bool值，这个bool值为true则代表接收成功，false代表channel已关闭，没有值可以接收。

```     					go
value , closed := <- ch
     if !closed{
     	//ch had closed
     }
```

<font color=red>注意:</font>如果通道关闭时，里面还有元素值未被取出，那么接收表达式的第一个结果仍会是通道中的某一个元素值，而第二个结果值一定会是true，因此，<font color=red>通过接收表达式的第二个结果值，判断通道是否关闭是可能存在延时的。</font>

**引起的死锁的常见场景**

死锁是指两个或两个以上的协程在执行过程中，由于竞争资源或由于彼此通信而造成的一种阻塞现象，若无外力作用，他们将无法推进下去，解决死锁的方法是加锁。
	

1. 一个无缓冲通道在一个go协程中即读又写
2. 一个无缓冲通道在协程开启之前使用了通道
3. 无缓冲通道1和无缓冲通道2，在通道1中调用了通道2，在通道2中调用了通道1，如下代码：

```go
func main() {
c1, c2 := make(chan int), make(chan int)
go func() {
    for {
        select {
        case <-c1:
            c2 <- 10
        }
    }
}()
for {
    select {
    case <-c2:
        c1 <- 10
    }
}
```

​	**channel应用场景**

1. 异步调用的通知机制

2. routine的结合select可以做到多路复用

3. 单项的消息传递

4. 生产者和消费者的实现

5. 数据缓存

6. routine的负载均衡

使用中需要注意的问题

1. 有缓冲的channel，对于生产者消费者的协同，要考虑消费者的效率高于生产者，否则会出现写入的等待，如果是做网络数据接收，这时候会影响数据接收，引发连锁反应

2. 在多个goroutine之间的channel数据传递，需要业务层明确定义每个channel的状态和业务，确保状态机是明确的邮箱状态机。不要出现复杂的状态转换。


**举例**

channel的一个生产者到多个消费者的例子。

```go
package main
import (
    "fmt"
)
func main(){
    n:=10
    c:=make(chan int)
    done := make(chan bool)
    go func(){
        for i:=0;i<10;i++{
            c<-i
        }
        close(c)
    }()
    for i:=0;i<n;i++{
        go func(){
            for m:=range c{
                fmt.Println(m)
            }
            done <- true
        }()
    }
    for i:=0; i<n; i++{
        <-done
    }
}
```



  